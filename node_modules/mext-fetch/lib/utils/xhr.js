'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
/**
 * 用于解决fetch不支持部分xhr功能（onprogress等）
 * options已处理
 */

const forEach = require('lodash/forEach');

const isFunction = require('lodash/isFunction');

const constant_1 = require('./constant');

function request(options) {
  return new Promise((resolve, reject) => {
    const {
      method,
      url,
      params,
      body,
      headers,
      dataType,
      transformResponse,
      onDownloadProgress,
      onUploadProgress,
      timeout,
      withCredentials,
      cancelToken
    } = options;
    let xhr = new XMLHttpRequest();
    xhr.open(method, `${url}${params}`);
    forEach(headers, (v, k) => {
      xhr.setRequestHeader(k, v);
    });

    xhr.onload = () => {
      if (!xhr || xhr.readyState !== 4) {
        return;
      }

      if (xhr.status === 0 && !(xhr.responseURL && xhr.responseURL.indexOf('file:') === 0)) {
        return;
      }

      try {
        checkStatus({
          url,
          status: xhr.status,
          statusText: xhr.statusText
        });
      } catch (error) {
        error.mext = constant_1.COMMONERROR;
        reject(error);
      }

      const responseData =
        !dataType || dataType === 'string' || dataType === 'text'
          ? xhr.responseText
          : transformResponse(xhr.response);
      resolve(responseData);
      xhr = null;
    };

    if (timeout) {
      xhr.timeout = Number(timeout);
    }

    xhr.onerror = () => {
      const error = new Error('network error');
      error.mext = constant_1.COMMONERROR;
      reject(error);
      xhr = null;
    };

    xhr.ontimeout = () => {
      const error = new Error(`request ${url} timeout`);
      error.mext = constant_1.COMMONERROR;
      reject(error);
      xhr = null;
    };

    xhr.onabort = function onabort() {
      if (!xhr) {
        return;
      }

      const error = new Error(`request ${url} abort`);
      error.mext = constant_1.ABORTERROR;
      reject(error);
      xhr = null;
    };

    if (withCredentials) {
      xhr.withCredentials = true;
    }

    if (isFunction(onDownloadProgress)) {
      xhr.addEventListener('progress', onDownloadProgress);
    }

    if (isFunction(onUploadProgress) && xhr.upload) {
      xhr.upload.addEventListener('progress', onUploadProgress);
    }

    if (cancelToken && cancelToken.promise) {
      cancelToken.promise.then(cancel => {
        if (!xhr) {
          return;
        }

        if (cancel) {
          reject(cancel);
        }

        xhr.abort();
        xhr = null;
      });
    }

    xhr.send(body);
  });
}

exports.default = request;

function checkStatus(response) {
  if (response.status >= 200 && response.status < 300) {
    return response;
  }

  throw new Error(`${response.url}: ${response.statusText}`);
}

exports.checkStatus = checkStatus;
