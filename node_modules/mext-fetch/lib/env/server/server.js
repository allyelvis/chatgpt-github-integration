'use strict';
/**
 * NODE端请求
 */

Object.defineProperty(exports, '__esModule', {
  value: true
});

const server_1 = require('mext-utils/server');

const APIGateway_1 = require('../../utils/APIGateway');

const apiGatewayConfig = require('../../config/apiGateway');

const log_1 = require('../../utils/log');

const url_1 = require('./url');

const fetch_1 = require('../../utils/fetch');

let instance = new APIGateway_1.default();

class HttpClient {
  constructor(API_RETRY_TIME, API_APIGATEWAY_OPEN, timeout) {
    this.API_RETRY_TIME = API_RETRY_TIME;
    this.API_APIGATEWAY_OPEN = API_APIGATEWAY_OPEN;
    this.timeout = timeout;

    if (process.env.NODE_ENV === 'development') {
      instance = new APIGateway_1.default();
    }
  }

  async startFetch(options, retryTime = this.API_RETRY_TIME) {
    const { url } = options;

    try {
      const uri = await this.getUri(url);

      if (!/^http(s)?:/.test(uri)) {
        throw new Error(
          `请求地址[${url}]匹配的domain必须设置http协议，当前node请求的完整url为${uri}`
        );
      }

      const _time1 = Number(new Date());

      console.info(`[server-fetch-start]:${uri}`);

      try {
        const data = await fetch_1
          .default({ ...options, url: uri, timeout: this.timeout })
          .then(response => {
            if (response.status < 200 || response.status > 350) {
              // 需要重试
              throw new Error(`${response.url}: ${response.statusText}`);
            }

            return response;
          });

        const _time2 = Number(new Date());

        console.info(`[server-fetch-end]:${uri}(${_time2 - _time1}ms)`);
        return data;
      } catch (e) {
        if (retryTime > 0) {
          log_1.default.error(uri, 'server-fetch-retry');
          return this.startFetch(options, --retryTime);
        }

        log_1.default.error(e.message, 'server-fetch-error');
        return Promise.reject(e);
      }
    } catch (err) {
      log_1.default.error(err, 'apiGetWay-getUri-error');
      return Promise.reject(err);
    }
  }

  async getApiGatewayUri(url) {
    const apiGatewayServerIP = await instance.getApiServer();
    return `http://${apiGatewayServerIP}${url}`;
  }

  getUri(url) {
    if (Number(process.env.Browser) === 1) {
      return Promise.resolve(url);
    }

    if (this.API_APIGATEWAY_OPEN) {
      return this.getApiGatewayUri(url);
    }

    return Promise.resolve(url_1.getFullUrl(url));
  }
}

exports.default = options => {
  const { fetch: fetchConfig } = server_1.getMextConfig();
  const { timeout = 5000 } = fetchConfig;
  Object.assign(apiGatewayConfig, fetchConfig.apiGateway);
  const { API_RETRY_TIME, API_APIGATEWAY_OPEN } = apiGatewayConfig;
  const httpClient = new HttpClient(API_RETRY_TIME, API_APIGATEWAY_OPEN, timeout); // __headers 为后续服务端带cookie请求数据留
  // options.headers = Object.assign(...options.__headers, options.headers);
  // apiGetWay

  if (API_APIGATEWAY_OPEN) {
    Object.assign(options.headers || {}, {
      Host: url_1.getDomain(options.url)
    });
  }

  return httpClient.startFetch({ ...options });
};
