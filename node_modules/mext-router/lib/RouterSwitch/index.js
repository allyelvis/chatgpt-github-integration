'use strict';

var __decorate =
  (this && this.__decorate) ||
  function(decorators, target, key, desc) {
    var c = arguments.length,
      r =
        c < 3
          ? target
          : desc === null
          ? (desc = Object.getOwnPropertyDescriptor(target, key))
          : desc,
      d;
    if (typeof Reflect === 'object' && typeof Reflect.decorate === 'function')
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if ((d = decorators[i]))
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };

Object.defineProperty(exports, '__esModule', {
  value: true
});
/**
 * 路由层面的状态管理中间平台
 * 是联系上层base组件和下层的路由组件的沟通桥梁
 */

const React = require('react');

const mext_utils_1 = require('mext-utils');

const client_1 = require('mext-plugin/client');

const react_router_dom_1 = require('react-router-dom');

const context_1 = require('./context');

const Switch_1 = require('./Switch');
/**
 * 路由状态管理核心组件
 */

let Router = class Router extends React.Component {
  constructor(props, context) {
    super(props, context);
    this.needUpdateInitialState = true;
    this.renderNum = 0;
    this.state = {
      mext_initialState: context.mext_initialState,
      match_routes: context.match_routes,
      pathname: context.pathname,
      diffRoutes: context.match_routes,
      location_search: context.location_search,
      loading: null
    };

    if (process.env.RUN_ENV === 'node') {
      // 确认渲染到路由组件了，便于服务端确认出错是否来自路由内组件渲染
      if (context.routerError && typeof context.routerError === 'function') {
        context.routerError();
      }
    }
    /**
     * 给客户端路由核心处理提供回调
     * 当路由切换前进行数据加载，通过该方法可以更新最新的数据内容
     */

    if (context.updateInitialState) {
      context.updateInitialState(
        ({
          mext_initialState = {},
          match_routes,
          diffRoutes,
          location_search = '',
          pathname,
          error = null
        }) => {
          /**
           * 这里的回调触发，是在路由切换时，需要加载的一些数据
           * 会通过context回调方式，传到这里，然后会立即更新当前组件
           */
          if (error) {
            // console.log('路由切换前出现错误异常', error);
            this.setState({
              mext_initialState: { ...this.state.mext_initialState, MextException: error },
              match_routes,
              diffRoutes,
              pathname,
              location_search
            });
          } else {
            // console.log('路由切换前更新路由核心组件数据');
            this.setState({
              mext_initialState: {
                ...this.state.mext_initialState,
                ...mext_initialState,
                MextException: null
              },
              match_routes,
              diffRoutes,
              pathname,
              location_search
            });
          }
        }
      );
    } // 获取该组件的mext_initialState

    if (context.getInitialState) {
      context.getInitialState(() => {
        return this.state.mext_initialState;
      });
    }

    if (context.forceRenderRouter) {
      context.forceRenderRouter(() => {
        this.forceUpdate();
      });
    }
  }

  shouldComponentUpdate(nextProps, nextState) {
    const cache = [];
    Object.keys(nextState.mext_initialState).forEach(item => {
      if (/^\//.test(item)) {
        cache.push(item);
      }
    }); // 缓存最近8种不同地址的路由数据

    if (cache.length > 8) {
      delete nextState.mext_initialState[cache[0]];
    } // 保证全局数据的一致性，主要在进行页面切换时，能及时获取缓存数据进行页面响应

    if (process.env.NODE_ENV === 'development') {
      if (this.context.syncInitialState) {
        this.context.syncInitialState(nextState.mext_initialState);
      }
    }

    if (!this.needUpdateInitialState) {
      this.needUpdateInitialState = true;
      return false;
    }

    return true;
  }

  async componentDidCatch(error) {
    client_1.default.hooks.catchError({
      type: 'router',
      error
    });
    const errorInfo = await mext_utils_1.Exception.handleError.call(null, error, component => {
      this.setState({
        loading: component
      });
    });
    this.setState({
      loading: null,
      mext_initialState: { ...this.state.mext_initialState, MextException: errorInfo }
    });
  }

  render() {
    if (!this.context.routes) {
      throw new Error('当前项目使用了路由，但是在编译阶段未识别到，请联系管理员');
    }

    if (this.state.loading) {
      const { loading } = this.state;

      if (React.isValidElement(loading)) {
        return React.cloneElement(
          loading,
          typeof loading.type === 'string'
            ? {}
            : {
                data: this.state.mext_initialState,
                routerError: true
              }
        );
      }

      if (typeof loading === 'function') {
        return React.createElement(loading, {
          data: this.state.mext_initialState,
          routerError: true
        });
      }

      return null;
    }

    const mext_initialState = this.state.mext_initialState;

    if (mext_initialState && mext_initialState.MextException) {
      const MextException = mext_initialState.MextException; // 如果存在要显示错误的组件

      if (MextException.url) {
        if (process.env.RUN_ENV === 'web') {
          if (/^http(s)?/.test(MextException.url)) {
            window.location.href = MextException.url;
            return null;
          }
        }

        return React.createElement(react_router_dom_1.Redirect, {
          to: MextException.url
        });
      }

      const ErrorComponent = mext_utils_1.Exception.shot();
      this.needUpdateInitialState = false;
      mext_utils_1.loadParams.set({
        isRenderRouter: false
      });
      return React.createElement(ErrorComponent, Object.assign({}, MextException));
    } // 执行核心路由组件的绘制

    if (this.renderNum === 0) {
      this.renderNum = this.state.diffRoutes.length;
    }

    return React.createElement(
      context_1.default.Provider,
      {
        value: {
          updateState: (url, data) => {
            /**
             * 保持当前控制器的所有数据都是最新的
             * 通过子组件获取然后回调通知当前组件，最后将数据存储到state里面，不做任何渲染
             */
            this.needUpdateInitialState = false;
            const _mext_initialState = this.state.mext_initialState;

            if (_mext_initialState.hasOwnProperty(url)) {
              _mext_initialState[url] = { ..._mext_initialState[url], ...data };
            } else {
              _mext_initialState[url] = data;
            } // console.log('更新路由组件变更数据，不导致Router组件渲染');

            this.setState({
              mext_initialState: { ...this.state.mext_initialState, ..._mext_initialState }
            });
          },
          updateError: err => {
            // console.log('更新路由组件时发生错误，会直接展示错误');
            this.setState({
              mext_initialState: { ...this.state.mext_initialState, MextException: err }
            });
          },
          routerDidUpdate: (fn, data) => {
            setTimeout(() => {
              if (fn) {
                mext_utils_1.emitter.getEmitter().emit('routeDidUpdate', {
                  data: { ...data, __mext__data__: this.state.mext_initialState },
                  fn
                });
              }

              this.renderNum--;

              if (this.renderNum === 0) {
                mext_utils_1.emitter
                  .getEmitter()
                  .emit('routerDidUpdate', this.state.mext_initialState);
              }
            }, 0);
          },
          data: this.state.mext_initialState,
          match_routes: this.state.match_routes,
          location_search: this.state.location_search,
          updateProps: this.context.updateProps,
          isRender: this.context.isRender
        }
      },
      React.createElement(Switch_1.default, {
        routes: this.context.routes
      })
    );
  }
};
Router.contextType = mext_utils_1.MextRouterContext;
Router = __decorate([mext_utils_1.unmountsetState], Router);
/**
 * 负责Mext框架路由整体调度的组件
 *
## 示例
```jsx
<RouterSwitch>
  <Route path="/" component={() => null} redirect="/home" exact />
  <Route path="/user/:id" component={User}>
    <Route path="/user/:id/post/:postId" component={UserPost} exact />
    <Route path="/user/:id/profile" component={UserProfile} exact />
  </Route>
  <Route path="/test" component={Test} />
  <Route path="/about" component={About} exact />
  <Route path="/home" component={Home} exact />
  <Route path="/404" component={() => <h1>404!</h1>} exact />
  <Route redirect="/404" />
</RouterSwitch>
```
 */

class RouterSwitch extends React.Component {
  shouldComponentUpdate() {
    return false;
  }

  render() {
    if (this.props.children) {
      return React.createElement(Router, null);
    }

    return null;
  }
}

exports.default = RouterSwitch;
