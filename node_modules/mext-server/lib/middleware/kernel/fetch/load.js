'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

const mext_utils_1 = require('mext-utils');

const node_1 = require('mext-plugin/node');

exports.default = async ctx => {
  if (ctx.mext.cache) {
    return;
  }

  try {
    const RootComponent = ctx.mext.RootComponent;

    if (RootComponent) {
      try {
        // 服务端处理，需要和context上下文挂钩
        const setMext = obj => {
          if (obj.constructor === Object && Object.keys(obj).length) {
            ctx.mext.initialState.mext = { ...(ctx.mext.initialState.mext || {}), ...obj };
          } else {
            console.warn('setMext必须接受一个不为空的对象');
          }
        }; // 初始化参数

        const initialPropsParams = {
          query: ctx.request.query,
          req: ctx.request,
          setMext,
          routes: ctx.mext.match_routes,
          route: null,
          match: null
        };
        await node_1.default.hooks.modifyInitialPropsCtx({
          params: initialPropsParams,
          context: ctx
        });

        try {
          /**
           * 执行入口的getInitialProps方法
           */
          if (RootComponent.getInitialProps) {
            const _props = {};
            _props.mext = await RootComponent.getInitialProps(initialPropsParams);
            _props.mext = { ...ctx.mext.initialState.mext, ..._props.mext };
            ctx.mext.initialState = { ...ctx.mext.initialState, ..._props };
          }
        } catch (error) {
          // 根组件加载数据发生错误
          ctx.set('X-Mext-Fetch', 'root');
          throw error;
        }
        /**
         * 根据匹配到的路由列表，执行对应路由的getInitialProps方法
         */

        const errorPath = {
          path: null
        };

        try {
          const loadMatchRoutes = [];
          ctx.mext.match_routes.forEach(match_route => {
            if (!match_route.route.client) {
              loadMatchRoutes.push(match_route);
            }
          });
          const { props } = await mext_utils_1.loadInitialProps(
            loadMatchRoutes,
            ctx.mext.search,
            initialPropsParams,
            ctx.mext.match_routes,
            errorPath
          );

          if (Object.keys(props).length) {
            ctx.mext.initialState = { ...ctx.mext.initialState, ...props };
          }
        } catch (error) {
          // 路由组件加载数据发生错误
          ctx.set('X-Mext-Fetch', Buffer.from(`【router】${errorPath.path}`).toString('base64'));
          throw error;
        }

        await node_1.default.hooks.didFetch({
          context: ctx
        });
      } catch (error) {
        ctx.mext.error = true; // 接口数据出错，默认走路由错误

        if (ctx.mext.routes.length) {
          // 存在路由
          ctx.mext.routerError = true;
        }

        throw error;
      }
    }
  } catch (error) {
    ctx.status = 500;
    throw error;
  }
};
