'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

const server_1 = require('mext-utils/server');

const _ = require('lodash');

const page_error_1 = require('../../utils/page_error');

function default_1(version) {
  const self = this;
  return async function BasicInitMiddleware(ctx, next) {
    try {
      const url = ctx.request.url; // 定义X-Powered-By

      ctx.set('X-Powered-By', `mext ${version}`);

      if (url === '/healthcheck') {
        // 健康检查
        console.info(`${new Date()}: ___healthcheck`);
        ctx.body = 'healthCheck success';
      } else if (url === '/favicon.ico') {
        ctx.status = 200;

        if (self.favicon) {
          ctx.type = 'jpg';
          ctx.body = self.favicon;
        } else {
          ctx.body = '';
        }
      } else {
        await next();
      }
    } catch (err) {
      const addErrorHeader = errorH => {
        ctx.set(
          'X-Mext-Error',
          Buffer.from(_.isError(errorH) ? errorH.message : JSON.stringify(errorH)).toString(
            'base64'
          )
        );
      }; // node服务器发生错误

      const finish = finishError => {
        addErrorHeader(finishError);

        if (self.dev && !self.ignore) {
          // 系统默认页面
          throw finishError;
        } else {
          // 默认提示文字，主要不能导致服务一直pendding
          ctx.body = '<meta charset="utf-8"/><p>无法访问此网站，请稍后再试</p>';
        }
      }; // 封装下context下的log

      const contextLog = (info, type) => {
        return server_1.log(info, type, {
          url: ctx.path,
          userAgent: ctx.request.headers['user-agent'],
          referer: ctx.request.headers.referer,
          host: ctx.host
        });
      };

      addErrorHeader(err);
      /**
       * 错误处理, 优先接收 err.status, 比如处理404
       */

      ctx.status = err.status || 500;
      self.ErrorCatchFunction(contextLog(err, 'node'));

      if (self.dev && !self.ignore) {
        // 如果没有设置忽略，将展示系统默认错误页面
        throw err;
      }

      if (!ctx.mext) {
        // 即解析层就发生错误了
        return finish(err);
      }

      try {
        // 渲染提供的错误组件页面
        if (self.routes.size !== 0) {
          // 存在路由，强制将错误塞到RouterSwitch组件内
          if (typeof err.routerError === 'boolean' && err.routerError === false) {
            ctx.mext.routerError = false;
          } else {
            ctx.mext.routerError = true;
          }
        } else {
          // 当前项目没有路由，那么就是false了
          ctx.mext.routerError = false;
        }

        ctx.mext.error = true;
        ctx.body = await page_error_1.default(err, ctx, self.renderReactToString);
      } catch (error) {
        addErrorHeader(error); // 渲染错误页面时出现了错误

        if (self.dev && !self.ignore) {
          // 如果没有设置忽略，将展示系统默认错误页面
          throw error;
        }

        ctx.status = 500;
        let newError = error;

        try {
          if (ctx.mext.routerError) {
            // 渲染错误定位到Layout层面，这个时候渲染全局展示的错误页面
            self.ErrorCatchFunction(contextLog(newError, 'renderLayout')); // 路由内错误在渲染错误页面时，全局报错，这个时候需要直接渲染错误页面

            ctx.mext.routerError = false;
            ctx.body = await page_error_1.default(error, ctx, self.renderReactToString);
            return;
          }
        } catch (error) {
          newError = error;
        } // 错误展示页面确实发生错误了

        self.ErrorCatchFunction(contextLog(newError, 'renderErrorPage'));
        return finish(newError);
      }
    }
  };
}

exports.default = default_1;
