'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
/**
 * Server对象的基础类
 */

const Koa = require('koa');

const immutable_1 = require('immutable');

const fs = require('fs-extra');

const Path = require('path');

const _ = require('lodash');
/** 基础中间件 */

const https_1 = require('../middleware/basic/https');

const init_1 = require('../middleware/basic/init');

const external_1 = require('../middleware/basic/external');

const static_1 = require('../middleware/basic/static');

const proxy_1 = require('../middleware/basic/proxy');
/** 核心中间件 */

const init_2 = require('../middleware/kernel/init');

const cache_1 = require('../middleware/kernel/cache');

const fetch_1 = require('../middleware/kernel/fetch');

const render_1 = require('../middleware/kernel/render');

const server_1 = require('mext-utils/server');

const node_1 = require('mext-plugin/node');

const mext_utils_1 = require('mext-utils');

const pkg = require('../../package.json');
/**
 * 定义核心变量
 */

let isCore = false;

class Base {
  /**
   * Server初始化构造函数之参数说明
   *
   * @param isProxy     标识是否启用proxy获取数据
   * @param port        指定当前服务器的端口号
   * @param ignore      忽略显示系统默认错误，仅在开发环境生效，主要用于错误页面开发
   * @param apiServer   标识当前的服务器是否仅仅可以作为一个接口数据代理服务，比如可以当作一个mock服务器或者proxy服务器
   */
  constructor({
    dev = false,
    isMock = false,
    isProxy = false,
    port = 1234,
    ignore = false,
    apiServer = false,
    devFun = null
  } = {}) {
    this.logFilterInfo = [];
    /** log过滤关键词 */

    this.ErrorCatchFunction = null;
    this.renderReactToString = null;
    this.manifestFile = '';
    /** manifest文件 */

    this.favicon = null;
    /** favicon图标 */

    this.httpsOptions = {};
    /** https配置信息 */

    /**
     *
     * ***
     * [
     *
     * `1`,`https中间件`
     *
     * `2`,`初始化数据中间件`
     *
     * `3`,`外部文件中间件`
     *
     * `4`,`静态资源中间件`
     *
     * `5`,`代理服务中间件`
     *
     * `6`,`核心参数ctx.mext注册中间件`
     *
     * ]
     * ***
     */

    this.middlewares = [];
    /**
     * 系统内置中间件
     *
     * 服务端渲染执行中间件，不能被随意销毁
     * 1. 判断是否缓存，命中缓存 cache
     * 2. 根据匹配到的地址解析对应接口数据 fetch
     * 3. 根据接口数据、匹配组件渲染出html render
     */

    this.coreMiddlewares = [];
    this.beforeCoreMiddlewares = [];
    this.afterCoreMiddlewares = [];
    process.env.RUN_ENV = 'node';

    if (devFun) {
      devFun();
    } else {
      process.env.NODE_ENV = process.env.NODE_ENV || 'production';
    }

    this.dev = dev;
    this.dir = process.cwd();
    this.isMock = isMock;
    this.isProxy = isProxy;
    this.port = port;
    this.apiServer = apiServer;
    this.app = new Koa();
    /** 设置获取的数据不可变 */

    const config = server_1.getMextConfig(this.dir);
    mext_utils_1.loadParams.set({
      basename: config.basename
    });

    if (config.plugins && config.plugins.length) {
      node_1.default.unregister();
      node_1.default.register(config.plugins);
    } // 处理basename中间件

    this.app.use(async (ctx, next) => {
      ctx.mextConfig = config;

      if (this.dev) {
        ctx.mextConfig = server_1.getMextConfig(this.dir, true);
      }

      if (config.basename) {
        const reg = new RegExp(`^${config.basename}`);

        if (reg.test(ctx.path)) {
          ctx.path = ctx.path.replace(reg, '');

          if (!ctx.path) {
            ctx.path = '/';
          }
        }
      }

      await next();
    });
    this.config = immutable_1.Seq(config);
    this.ignore = ignore;
    this.RootPageEntry = '';
    this.routes = immutable_1.fromJS([]);
    this.RootComponent = null;
    this.RootDocumentComponent = null;
    this.map = immutable_1.Seq({});
    this.extensions(config);

    this.ErrorCatchFunction = info => {
      if (info && _.isObject(info)) {
        // 向终端打印日志
        console.error(JSON.stringify(info));
      }
    };

    global.AppRegistry = Component => {
      this.RootComponent = Component;
    };
    /**
     * 证书判断
     */

    if (this.port === '443') {
      const _pkg = require(Path.join(this.dir, 'package.json'));

      const key = Path.join(this.dir, _pkg.name + '.key');
      const cert = Path.join(this.dir, _pkg.name + '.crt');

      if (!fs.existsSync(key)) {
        throw new Error(`https需要的key不存在，存储路径为:${key}`);
      }

      if (!fs.existsSync(cert)) {
        throw new Error(`https需要的cert不存在，存储路径为:${cert}`);
      }

      this.httpsOptions = {
        key: fs.readFileSync(key),
        cert: fs.readFileSync(cert)
      };
    }
  }
  /**
   * 注册中间件
   */

  registerMiddlewares() {
    this.middlewares.push(
      https_1.default.call(this),
      init_1.default.call(this, pkg.version),
      external_1.default.call(this),
      static_1.default.call(this),
      proxy_1.default.call(this),
      init_2.default.call(this)
    );

    if (!this.apiServer) {
      this.coreMiddlewares.push(cache_1.default(), fetch_1.default(), render_1.default.call(this));
    }
  }
  /**
   * 开启require扩展识别，开发环境被重写
   */

  extensions(config) {
    server_1.extensions(config);
  }
  /**
   * 挂载所有中间件
   */

  loadAllMiddlewares() {
    this.middlewares.forEach(middleware => {
      this.app.use(middleware);
    });
  }
  /**
   * 中间件
   */

  use(middleware) {
    if (isCore) {
      this.afterCoreMiddlewares.push(middleware);
    } else {
      this.beforeCoreMiddlewares.push(middleware);
    }
  }
  /**
   * 核心
   */

  core() {
    isCore = true;
  }
  /**
   * 日志过滤器
   */

  logFilter() {
    this.logFilterInfo = Array.from(arguments);
  }

  log(cb) {
    this.handleError(cb);
  }
  /**
   *
   * 开发者可以根据node产生的错误进行自定义过滤出来
   *
   * 回调参数的error对象数据仅生产环境生效
   *
   * 如果没有将errLogs返回，那么将不会打印错误日志
   *
   * ```
   * app.catch(errLogs => {
   *   // 开发阶段、errLogs为null
   *   // 可以自行处理errLogs，决定是否将错误errLogs发送到终端，即打印日志
   *   return newErrLogs;
   * })
   * ```
   *
   */

  catch(cb) {
    this.handleError(cb);
  }

  router(root, routerFile) {
    this.routerRoot = root;
    this.routerFile = routerFile;
  }

  handleError(cb) {
    if (typeof cb === 'function') {
      this.ErrorCatchFunction = errLogs => {
        // 触发回调catch处理当前错误日志
        const info = cb(errLogs);

        if (info && _.isObject(info)) {
          // 向终端打印日志
          console.error(JSON.stringify(info));
        }
      };
    }
  }
}

exports.default = Base;
