'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

const React = require('react');

const react_router_config_1 = require('react-router-config');

const mext_utils_1 = require('mext-utils');

const client_1 = require('mext-plugin/client');

const kernal_1 = require('./kernal');

const routerLifecycle_1 = require('./utils/routerLifecycle');

const routesDiff_1 = require('./utils/routesDiff');

const fetch_1 = require('./utils/fetch');

const redirect_1 = require('./utils/redirect');
/**
 * 客户端代码首次渲染执行
 */

async function RouteEntry(Component, INITIAL_STATE, routes) {
  let needClient = false;

  try {
    // 存储路由生命周期钩子函数
    routerLifecycle_1.routerWillUpdate.set(Component);
    routerLifecycle_1.routerDidUpdate.set(Component);
    const { ssr, basename } = mext_utils_1.loadParams.get(); // 当前项目没有设置路由，且发生错误了，需要直接渲染错误页面

    const locationInfo = mext_utils_1.realPath(basename, mext_utils_1.pathname());
    let match_routes = react_router_config_1.matchRoutes(routes, locationInfo);
    let match_length = match_routes.length;
    /**
     * 不涉及组件层面的处理，不需要进行loadBundle
     */
    // 匹配到路由了

    if (match_length) {
      // 触发第一个match_routes记录
      routesDiff_1.default(match_routes, mext_utils_1.search());
    } // 客户端渲染和热更新时触发当前条件

    if (!ssr) {
      /**
       * 判断重定向，如果是服务器执行，服务端会优先执行重定向
       * 如果纯客户端执行代码，这里客户端会进行浏览器跳转刷新
       */
      const redirectUrl = await redirect_1.default(match_routes, match_length, locationInfo);

      if (redirectUrl) {
        mext_utils_1.redirect(redirectUrl);
        return [() => null, needClient];
      }
    } // 如果最后匹配到的路由path没有定义

    /** 如果最后匹配到的路由path没有定义 */

    let match = true;

    if (match_length) {
      // <Route />
      const info = match_routes[match_length - 1];

      if (Object.keys(info.route).length === 0) {
        match = false;
      }
    } else {
      if (locationInfo !== '/') {
        match = false;
      }
    } // 加载对应路由的js-bundle，初始化路由对应的组件
    // webpack会删除该段代码

    if (process.env.NODE_ENV === 'development') {
      INITIAL_STATE = window.hmr_initialState || INITIAL_STATE;
    }

    await mext_utils_1.loadBundles(match_routes, mext_utils_1.search(), INITIAL_STATE); // 判断是否阻止通过，即当热更新时，阻止某些代码执行

    let pass = true; // webpack会删除该段代码

    if (process.env.NODE_ENV === 'development') {
      if (window.mext_hmr) {
        pass = false;
      }
    }

    if (pass) {
      // 执行初始化插件
      await client_1.default.hooks.init({
        Component,
        INITIAL_STATE,
        match_routes
      });
    }
    /**
     * 热更新不执行
     */

    if (pass) {
      // 获取数据
      needClient = await fetch_1.default(Component, match_routes, INITIAL_STATE, routes); // 客户端直接渲染404页面

      if (!match) {
        INITIAL_STATE.MextException = await mext_utils_1.Exception.handleError.call(null, {
          status: 404
        });
      } // 触发路由更新前钩子

      if (
        !(await routerLifecycle_1.routerWillUpdate({
          to: {
            match_routes,
            location: {
              pathname: locationInfo
            }
          },
          from: {},
          history: {},
          data: INITIAL_STATE
        }))
      ) {
        return [() => null, needClient];
      }
    } // 注册路由组件

    return [kernal_1.default(routes, match_routes, INITIAL_STATE, Component), needClient];
  } catch (error) {
    console.error('客户端初始化代码出错', error);
    return [
      () =>
        React.createElement(
          'p',
          null,
          '\u65E0\u6CD5\u8BBF\u95EE\u6B64\u7F51\u7AD9\uFF0C\u8BF7\u7A0D\u540E\u518D\u8BD5'
        ),
      needClient
    ];
  }
}

exports.default = async (Component, INITIAL_STATE, routes) => {
  const [ComponentType, needClient] = await RouteEntry(Component, INITIAL_STATE, routes);
  ComponentType.needClient = needClient;
  return ComponentType;
};
