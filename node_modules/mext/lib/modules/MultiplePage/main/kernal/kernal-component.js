'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
/**
 * 几个核心组件
 * provider
 * router
 * prompt
 * root
 */

const React = require('react');

const react_router_dom_1 = require('react-router-dom');

const mext_utils_1 = require('mext-utils');

const client_1 = require('mext-plugin/client');

const lifecycle_1 = require('./lifecycle');

const render_1 = require('../utils/render');

const fetch_root_1 = require('../utils/fetch-root');

class KernalComponent extends lifecycle_1.default {
  /**
   * 该Provider只提供初始化组件时的数据传递，该组件状态将不再更新
   *
   * 把客户端入口整理的数据，通过context传递给路由RouterSwitch组件使用
   * 同理，服务端也有类似的组件
   */
  provider() {
    const value = {
      routes: this.routes,
      match_routes: this.match_routes,
      mext_initialState: this.mext_initialState,
      location_search: mext_utils_1.search(),
      pathname: this.pathname,
      updateProps: this.updateProps,
      updateInitialState: cb => {
        this.updateInitialState = cb;
      },
      getInitialState: cb => {
        this.getInitialState = cb;
      },
      getHistory: history => {
        mext_utils_1.mextHistory.storeHistory(history);
        this.history = history;
      },
      forceRenderRouter: cb => {
        this.forceRenderRouter = cb;
      },
      isRender: () => {
        return render_1.default.get();
      }
    };

    if (process.env.NODE_ENV === 'development') {
      // 开发环境热更新数据使用
      value.syncInitialState = mext_initialState => {
        window.hmr_initialState = mext_initialState;
      };
    }

    return props =>
      React.createElement(
        mext_utils_1.MextRouterContext.Provider,
        {
          value: value
        },
        props.children
      );
  }
  /**
   * 提供路由的Router渲染，根据配置，选择history还是hash类型的路由
   */

  router() {
    const Router =
      process.env.ROUTER === 'hash'
        ? react_router_dom_1.HashRouter
        : react_router_dom_1.BrowserRouter;
    const { basename } = mext_utils_1.loadParams.get();
    const getUserConfirmation = this.getUserConfirmation.bind(this); // 由于Router组件的children必须是组件，所有用fragment包裹一下

    return props =>
      React.createElement(
        Router,
        {
          basename: basename,
          getUserConfirmation: getUserConfirmation
        },
        React.createElement(React.Fragment, null, props.children)
      );
  }
  /**
   * 所有的路由组件切换生命周期钩子，都是依赖Prompt组件
   * 再配合Router上的getUserConfirmation钩子，实现了路由切换的逻辑处理
   */

  prompt() {
    const self = this;

    class PromptModal extends React.Component {
      constructor() {
        super(...arguments);
        this.state = {
          dom: null
        };
      }

      componentDidMount() {
        self.PromptContext = this;
      }

      render() {
        return React.createElement(React.Fragment, null, this.state.dom);
      }
    }

    function message(location, action) {
      return JSON.stringify({
        location,
        action
      });
    }

    return () =>
      React.createElement(
        React.Fragment,
        null,
        React.createElement(PromptModal, null),
        React.createElement(react_router_dom_1.Prompt, {
          message: message
        })
      );
  }
  /**
   * 根组件之高阶组件
   *
   * 提供全局错误处理
   * 回到顶部
   */

  root() {
    const self = this;

    class MextRoot extends React.Component {
      constructor(props) {
        super(props);
        this.reload = false;
        let errorInfo = null; // webpack会删除该段代码

        if (process.env.NODE_ENV === 'development') {
          if (window.mext_hmr && window.mext_hmr_error) {
            // 热更新
            errorInfo = window.mext_hmr_error;
          }
        } // 正常渲染，且发生的错误是路由外的才录用

        if (
          !errorInfo &&
          self.mext_initialState.MextException &&
          !self.mext_initialState.MextException.routerError
        ) {
          errorInfo = self.mext_initialState.MextException;
        }

        this.state = {
          errorInfo,
          loading: null,
          data: self.mext_initialState.mext
        };
      }

      async componentDidMount() {
        let updateProps = false;

        if (typeof self.updateProps === 'boolean') {
          updateProps = self.updateProps;
        } else if (typeof self.updateProps === 'function') {
          updateProps = await self.updateProps({ ...self.mext_initialState });
        }

        if (updateProps) {
          await fetch_root_1.default(self.getInitialProps, self.mext_initialState, self.routes);
          this.setState({
            errorInfo: self.mext_initialState.MextException || null,
            data: self.mext_initialState.mext
          });
        } // 路由内切换，需要清除全局错误

        self.cleanError = () => {
          // 清除热更新错误标记
          if (this.state.errorInfo) {
            if (process.env.NODE_ENV === 'development') {
              delete window.mext_hmr_error;
            }

            this.setState({
              errorInfo: null
            });
          }
        };
      }

      getSnapshotBeforeUpdate(prevProps) {
        if (this.props.location !== prevProps.location && self.scrollParam) {
          const { x, y, scroll } = self.scrollParam;

          if (scroll) {
            // 异步滚动
            setTimeout(() => {
              window.scrollTo(x, y);
            }, 0);
          }
        }

        return null;
      }

      componentDidUpdate() {
        return null;
      }
      /**
       * 捕获全局错误
       * @param error
       */

      async componentDidCatch(error) {
        client_1.default.hooks.catchError({
          type: 'global',
          error
        });
        const message = error.message ? error.message : null;
        const stack = error.stack ? error.stack : null;
        const errorInfo = await mext_utils_1.Exception.handleError.call(
          null,
          {
            message,
            stack,
            routerError: false
          },
          component => {
            this.setState({
              loading: component
            });
          }
        );

        if (process.env.NODE_ENV === 'development') {
          window.mext_hmr_error = errorInfo;
        }

        this.setState({
          errorInfo,
          loading: null
        });
      }

      render() {
        this.reload = false;

        if (this.state.loading) {
          const { loading } = this.state;

          if (React.isValidElement(loading)) {
            return React.cloneElement(
              loading,
              typeof loading.type === 'string'
                ? {}
                : {
                    data: self.mext_initialState,
                    routerError: false
                  }
            );
          }

          if (typeof loading === 'function') {
            return React.createElement(loading, {
              data: self.mext_initialState,
              routerError: false
            });
          }

          return null;
        }

        let renderElement = null;

        if (this.state.errorInfo) {
          const ErrorComponent = mext_utils_1.Exception.shot();
          renderElement = React.createElement(
            ErrorComponent,
            Object.assign({}, this.state.errorInfo)
          );
        }

        renderElement = renderElement || this.props.children || null;

        if (this.state.data.hasOwnProperty('reloadInitialProps')) {
          throw new Error('reloadInitialProps这是系统关键字，请不要使用该名称作为key');
        }

        const reloadInitialProps = async () => {
          if (!this.reload) {
            this.reload = true;
            await fetch_root_1.default(self.getInitialProps, self.mext_initialState, self.routes);
            this.setState({
              errorInfo: self.mext_initialState.MextException || null,
              data: self.mext_initialState.mext
            });
          } else {
            console.warn('当前根组件正在执行reloadInitialProps函数，请等待执行完毕！');
          }
        };

        return React.createElement(
          React.Fragment,
          null,
          React.createElement(mext_utils_1.MextRouterContext.Consumer, null, ({ getHistory }) => {
            getHistory(this.props.history);
            return null;
          }),
          renderElement &&
            React.cloneElement(renderElement, {
              match: this.props.match,
              location: this.props.location,
              history: this.props.history,
              ...this.state.data,
              reloadInitialProps
            })
        );
      }
    }

    return react_router_dom_1.withRouter(MextRoot);
  }
}

exports.default = KernalComponent;
