'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
/**
 * 公共方法类
 */

const React = require('react');

const ReactDOM = require('react-dom');

const mext_utils_1 = require('mext-utils');

const client_1 = require('mext-plugin/client');

const base_1 = require('./base');

class Common extends base_1.default {
  setParam(_location) {
    // 记录是否回到顶部参数
    let x = 0;
    let y = 0;
    let scroll = true;

    if (_location.data) {
      if (typeof _location.data.scroll === 'boolean') {
        scroll = _location.data.scroll;
      }

      if (_location.data.x) {
        x = _location.data.x;
      }

      if (_location.data.y) {
        y = _location.data.y;
      }
    }

    this.scrollParam = {
      x,
      y,
      scroll
    };
  } // 加载代码拆分后的静态资源

  loadBundles(new_match_routes, _location) {
    // 加载下个路由对应页面的所有的jsBundle
    return mext_utils_1.loadBundles(
      new_match_routes,
      _location.search.replace(/^\?/, ''),
      this.getInitialState()
    );
  } // 加载下个路由需要的数据

  async loadInitialProps(new_match_routes, _location, diffRoutes, pathname) {
    if (diffRoutes.length === 0) {
      // eslint-disable-next-line no-param-reassign
      diffRoutes = new_match_routes;
    }

    const search = _location.search.replace(/^\?/, '');

    const needInitiRoutes = diffRoutes.filter(item => item.route.needInitiProps);

    if (needInitiRoutes.length) {
      // 切换到下个路由页面之前，需要提取加载数据
      try {
        const initialProps = {
          location: _location,
          query: mext_utils_1.queryObj(search),
          setMext: mext_utils_1.setMext.get()
        };
        await client_1.default.hooks.modifyInitialPropsCtx({
          params: initialProps
        });
        const { props } = await mext_utils_1.loadInitialProps(
          needInitiRoutes,
          search,
          initialProps,
          new_match_routes
        ); // 通过RouterSwtich绑定的回调修改数据

        this.updateInitialState &&
          this.updateInitialState({
            mext_initialState: props,
            match_routes: new_match_routes,
            diffRoutes,
            pathname,
            location_search: search
          });
      } catch (err) {
        client_1.default.hooks.catchError({
          type: 'fetch',
          error: err
        });
        const errorInfo = await mext_utils_1.Exception.handleError.call(null, err); // 发送错误信号

        this.updateInitialState &&
          this.updateInitialState({
            match_routes: new_match_routes,
            diffRoutes,
            pathname,
            error: errorInfo
          });
      }
    } else {
      this.updateInitialState &&
        this.updateInitialState({
          match_routes: new_match_routes,
          diffRoutes,
          pathname,
          location_search: search
        });
    }
  } // 显示新的react组件

  async modal(to, from, component) {
    const confirm = await new Promise(resolve => {
      this.PromptContext.setState({
        dom: null
      });
      const modal = ReactDOM.createPortal(
        React.cloneElement(component, {
          to,
          from,

          stop() {
            resolve(false);
          },

          pass() {
            resolve(true);
          }
        }),
        document.body
      );
      this.PromptContext.setState({
        dom: modal
      });
    });
    this.PromptContext.setState({
      dom: null
    });
    return confirm;
  }
}

exports.default = Common;
