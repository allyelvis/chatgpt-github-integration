'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
/**
 * 开始渲染核心路由组件，继承方式
 * index > kernal-component -> lifecycle -> common -> base
 */

const React = require('react');

const mext_utils_1 = require('mext-utils');

const kernal_component_1 = require('./kernal-component');

const routerLifecycle_1 = require('../utils/routerLifecycle');

exports.default = (routes, match_routes, INITIAL_STATE, Component) =>
  /**
   * 入口组件渲染，处理react生命周期
   */
  class MextRouter extends kernal_component_1.default {
    constructor(props, context) {
      super(props, context, [Component, routes, match_routes, INITIAL_STATE]);
    }

    shouldComponentUpdate() {
      if (process.env.NODE_ENV === 'development') {
        if (window.mext_hmr) {
          return true;
        }
      }

      return false;
    }

    async componentDidMount() {
      let pass = true;

      if (process.env.NODE_ENV === 'development') {
        if (window.mext_hmr) {
          this.emitter.off('routeDidUpdate');
          this.emitter.off('routerDidUpdate');
          pass = false;
        }
      }

      if (pass) {
        const { firstRender, ssr } = mext_utils_1.loadParams.get();

        if (firstRender && !ssr && this.history) {
          // 首次渲染结束触发,触发重定向
          this.emitter.emit('routerWillUpdate_!ssr', this.history);
        }
      } // 监听单个路由的切换

      this.emitter.on('routeDidUpdate', info => {
        if (pass) {
          const { fn, data } = info;
          const to = this.target;
          const from = this.lastTarget;
          fn(to, from, data);
        } else {
          pass = true;
        }
      }); // 监听全局路由的切换

      this.emitter.on('routerDidUpdate', data => {
        if (pass) {
          routerLifecycle_1.routerDidUpdate({
            to: this.target,
            from: this.lastTarget,
            data
          });
        } else {
          pass = true;
        }
      }); // 如果发生错误了，将立刻触发routerDidUpdate

      if (INITIAL_STATE && INITIAL_STATE.MextException) {
        this.emitter.emit('routerDidUpdate', INITIAL_STATE);
      }
    }

    render() {
      const Provider = this.provider();
      const Router = this.router();
      const Root = this.root();
      const Prompt = this.prompt();
      return React.createElement(
        Provider,
        null,
        React.createElement(
          Router,
          null,
          React.createElement(Prompt, null),
          React.createElement(Root, null, React.createElement(Component, null))
        )
      );
    }
  };
