'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

const mext_utils_1 = require('mext-utils');

const render_1 = require('./render');
/**
 * 存储
 * routerWillUpdate
 * routerDidUpdate
 */

let _routerWillUpdate = null;
let _routerDidUpdate = null;
/**
 * 存储静态方法
 */

const setWillUpdate = Component => {
  if (Component.routerWillUpdate && typeof Component.routerWillUpdate === 'function') {
    _routerWillUpdate = Component.routerWillUpdate;
  }
};

const setDidUpdate = Component => {
  if (Component.routerDidUpdate && typeof Component.routerDidUpdate === 'function') {
    _routerDidUpdate = Component.routerDidUpdate;
  }
};
/**
 * 路由切换前钩子说明
 *
 * to 表示目标路由对象
 *
 *  from 表示来源，如果没有来源，比如非服务端渲染，刷新页面首次进入，默认为null
 *
 * 如果to和from都有意义，那么两者的数据结构是一致的
 *
 * history 表示react-router的跳转形式
 *
 * to和from数据格式
 *
 * 使用方式
 *
 * ```js
 *  // mext核心调用
 *  await routerWillUpdate({ to, from, history, data })
 *
 *  // 开发者使用
 *  // 根组件定义静态方法
 *  static routerWillUpdate(to, from, next, data){
 *  // 只有执行next才会进行下一步路由切换的动作
 *    next()
 *  }
 *  ```
 */

function routerWillUpdate({ to, from = null, history, data = null }) {
  return new Promise(resolve => {
    if (_routerWillUpdate) {
      _routerWillUpdate(
        to,
        from,
        value => {
          if (typeof value !== 'undefined') {
            if (typeof value === 'boolean') {
              resolve(value);
            } else {
              // 执行history跳转
              const { firstRender, ssr } = mext_utils_1.loadParams.get();
              let push = false;
              let nexLocation = {};

              if (typeof value === 'string') {
                nexLocation = {
                  pathname: value
                };
              } else if (typeof value === 'object') {
                const { replace = false, ...rest } = value;
                push = replace;
                nexLocation = rest;
              } else {
                console.warn('next函数接收的类型不正确');
                return resolve(false);
              }

              nexLocation.search = nexLocation.search || '';

              if (firstRender) {
                if (!ssr) {
                  // 非服务端渲染，在客户端执行首次渲染触发routerWillUpdate
                  // 这个时候需要注册history跳转的监听，同时说明，需要跳转
                  // 所以，需要先渲染出路由组件，然后再执行history跳转
                  render_1.default.set(false);
                  mext_utils_1.emitter.getEmitter().on('routerWillUpdate_!ssr', newhistory => {
                    render_1.default.set(true);
                    const method = push ? newhistory.push : newhistory.replace;
                    method(nexLocation);
                  });
                }

                resolve(true);
              } else {
                const targetLocationInfo = to.location.pathname + to.location.search;
                const nextLocationInfo = nexLocation.pathname + nexLocation.search;
                const method = push ? history.push : history.replace;
                const { basename } = mext_utils_1.loadParams.get();
                const currentLocationInfo = mext_utils_1.realPath(
                  basename,
                  mext_utils_1.pathname()
                );

                if (
                  targetLocationInfo !== nextLocationInfo &&
                  targetLocationInfo !== currentLocationInfo
                ) {
                  resolve(false);
                  method(nextLocationInfo);
                } else {
                  resolve(true);
                }
              }
            }
          } else {
            resolve(true);
          }
        },
        data
      );
    } else {
      resolve(true);
    }
  });
}

exports.routerWillUpdate = routerWillUpdate;
routerWillUpdate.set = setWillUpdate;

function routerDidUpdate({ to, from, data }) {
  if (_routerDidUpdate) {
    _routerDidUpdate(to, from, data);
  }
}

exports.routerDidUpdate = routerDidUpdate;
routerDidUpdate.set = setDidUpdate;
exports.default = {
  routerWillUpdate,
  routerDidUpdate
};
