'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

const React = require('react');

const node_1 = require('mext-plugin/node');

const server_1 = require('react-dom/server');

const server_2 = require('mext-utils/server');

const path = require('path');

const fs = require('fs-extra');

const structure_1 = require('./structure');

const cwd = process.cwd();
const filename = path.join(cwd, '.mext/.mextConfig/react-loadable.json');
let prodStats = null;

if (fs.existsSync(filename)) {
  prodStats = JSON.parse(fs.readFileSync(filename, 'utf-8'));
}

class DefaultDocument extends React.Component {
  render() {
    const { Head, Html, Script } = this.props;
    return React.createElement(
      'html',
      null,
      React.createElement('head', null, React.createElement(Head, null)),
      React.createElement(
        'body',
        null,
        React.createElement(Html, null),
        React.createElement(Script, null)
      )
    );
  }
}

const RenderComponent = ({ element }) => {
  const parse = ele => {
    if (ele) {
      if (React.isValidElement(ele)) {
        return ele;
      } else {
        const Element = ele;
        return React.createElement(Element, null);
      }
    }

    return ele;
  };

  if (Array.isArray(element)) {
    const eles = [];
    element.forEach((ele, index) => {
      eles.push(
        React.cloneElement(parse(ele), {
          key: index
        })
      );
    });
    return eles;
  } else {
    return parse(element);
  }
};
/**
 * ctx 上下文
 *
 * renderReactToString 渲染react组件的函数，开发环境生效
 */

exports.default = async (ctx, doc, renderReactToString, stats = prodStats) => {
  const { RootDocumentComponent = null } = ctx.mext;
  const DocumentComponent = RootDocumentComponent || DefaultDocument; // 触发渲染前钩子

  await node_1.default.hooks.beforeRender({
    context: ctx
  }); // 收集样式，初始化项目html文档

  const { head, script, html, bundleScript } = await structure_1.default(
    ctx,
    renderReactToString,
    stats
  );
  const docStruct = {
    beforeHead: [],
    afterHead: [],
    beforeScript: [],
    afterScript: [],
    beforeHtml: [],
    afterHtml: []
  };
  const handler = {
    get(target, key, receiver) {
      // 递归创建并返回
      if (typeof target[key] === 'object' && target[key] !== null) {
        return new Proxy(target[key], handler);
      }

      return Reflect.get(target, key, receiver);
    },

    set(target, key, value, receiver) {
      docStruct[key].push(value);
      return Reflect.set(target, key, null, receiver);
    },

    deleteProperty() {
      throw new Error('不能删除params.doc的字段');
    }
  };
  const params = {
    context: ctx,
    doc: new Proxy(
      {
        beforeHead: null,
        afterHead: null,
        beforeScript: null,
        afterScript: null,
        beforeHtml: null,
        afterHtml: null
      },
      handler
    )
  }; // 组装document

  await node_1.default.hooks.document(params);
  const myDoc = {
    Head: () =>
      React.createElement(
        React.Fragment,
        null,
        React.createElement('meta', {
          charSet: 'utf-8'
        }),
        React.createElement(RenderComponent, {
          element: docStruct.beforeHead
        }),
        head,
        doc.head,
        React.createElement(RenderComponent, {
          element: docStruct.afterHead
        })
      ),
    Html: props =>
      React.createElement(
        React.Fragment,
        null,
        React.createElement(RenderComponent, {
          element: docStruct.beforeHtml
        }),
        html === '' && props.loading
          ? React.createElement(
              'div',
              {
                id: 'mext'
              },
              React.createElement(RenderComponent, {
                element: props.loading
              })
            )
          : React.createElement('div', {
              id: 'mext',
              dangerouslySetInnerHTML: {
                __html: html
              }
            }),
        React.createElement(RenderComponent, {
          element: docStruct.afterHtml
        })
      ),
    Script: () =>
      React.createElement(
        React.Fragment,
        null,
        React.createElement(RenderComponent, {
          element: docStruct.beforeScript
        }),
        React.createElement('script', {
          dangerouslySetInnerHTML: {
            __html: `window.__INITIAL_STATE__ = ${server_2.htmlescape(
              JSON.stringify(doc.initialState)
            )};`
          }
        }),
        script,
        doc.script,
        bundleScript,
        React.createElement(RenderComponent, {
          element: docStruct.afterScript
        })
      ),
    context: ctx,
    assetPrefixs: doc.assetPrefixs
  };
  let data = {};

  if (typeof DocumentComponent.getInitialProps === 'function') {
    data = await DocumentComponent.getInitialProps(myDoc);
  } // 直出html页面

  const finalHtml =
    '<!DOCTYPE html>' +
    server_1.renderToString(React.createElement(DocumentComponent, Object.assign({}, myDoc, data))); // 触发渲染后钩子

  await node_1.default.hooks.afterRender({
    context: ctx,
    html: finalHtml
  });
  return finalHtml;
};
