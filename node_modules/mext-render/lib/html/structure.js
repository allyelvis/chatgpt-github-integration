'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

const React = require('react');

const fs = require('fs-extra');

const react_helmet_1 = require('react-helmet');

const node_1 = require('mext-plugin/node');

const server_1 = require('react-dom/server');

const webpack_1 = require('react-loadable/webpack');

const path = require('path');

const styleModulefile = path.join(process.cwd(), 'node_modules/.cache/mext/.moduleStyles.json');

const createStyleLink = ctx => {
  const {
    dev,
    map,
    config: { assetPrefixs, hashName },
    match_routes
  } = ctx.mext;
  const linkStyle = [];
  const css = [];
  let i = 0;

  if (!dev) {
    // 存在第三方依赖的静态资源
    if (map.moduleStyles && map.moduleStyles[0]) {
      css.push(map.moduleStyles[0]);
    }

    match_routes.forEach(item => {
      // 读取当前匹配到的chunk样式资源
      const file = item.route.__mext__file__;

      if (file) {
        if (map[file]) {
          css.push(map[file]);
        }

        if (map.moduleStyles && map.moduleStyles[file]) {
          css.push(...map.moduleStyles[file]);
        }
      }
    });

    if (map[0]) {
      // 存在公共资源
      linkStyle.push(
        React.createElement('link', {
          key: i,
          rel: 'stylesheet',
          type: 'text/css',
          href: `${assetPrefixs}styles/${hashName ? map[0] : 'main.css'}`
        })
      );
      i++;
    }
  } else {
    let moduleStyles = {};

    if (fs.existsSync(styleModulefile)) {
      moduleStyles = JSON.parse(fs.readFileSync(styleModulefile, 'utf-8'));
    } // 开发环境存在第三方依赖的静态资源

    if (moduleStyles) {
      if (moduleStyles[0]) {
        css.push(moduleStyles[0]);
      }

      match_routes.forEach(item => {
        // 读取当前匹配到的chunk样式资源
        const file = item.route.__mext__file__;

        if (file) {
          if (moduleStyles[file]) {
            css.push(...moduleStyles[file]);
          }
        }
      });
    }
  }

  css.forEach(item => {
    linkStyle.push(
      React.createElement('link', {
        key: i,
        rel: 'stylesheet',
        type: 'text/css',
        href: `${assetPrefixs}styles/${item}`
      })
    );
    i++;
  });

  if (dev) {
    linkStyle.push(
      React.createElement('link', {
        key: i,
        rel: 'stylesheet',
        type: 'text/css',
        href: `${assetPrefixs}mext.css`
      })
    );
  }

  return linkStyle;
};

exports.default = async (ctx, renderReactToString, stats) => {
  const {
    config: { router, mode },
    RootComponent
  } = ctx.mext;
  let html = '';
  let head = null;
  let bundles = [];
  const params = {
    Component: React.createElement(RootComponent, null),
    context: ctx
  }; // 触发渲染钩子

  await node_1.default.hooks.render(params);

  if (renderReactToString) {
    // 可以自定义渲染场景
    const render = await renderReactToString(params.Component, ctx);

    if (render) {
      html = render.html || '';
      head = render.head || null;
      bundles = render.bundles || [];
    }
  } else {
    /**
     * 以下场景，才会把当前组件渲染出来
     * 1. 服务端渲染场景
     * 2. 单页导出
     */
    if (
      RootComponent &&
      ((router === 'browser' && mode === 'server') || process.env.WEB_TYPE === 'WEB_SPA')
    ) {
      html = server_1.renderToString(params.Component);
    }

    head = react_helmet_1.Helmet.renderStatic();
    bundles = stats ? webpack_1.getBundles(stats, ctx.mext.modules) : [];
  }

  let title = null;
  let meta = null;
  let link = null;
  const headScript = [];
  const footerScript = [];
  const bundleScript = [];
  const bundleStyle = [];

  if (head && html !== '') {
    link = head.link.toComponent();
    meta = head.meta.toComponent();
    title = head.title.toComponent();
    const script = head.script.toComponent();
    script.forEach(item => {
      if (item.props.head) {
        headScript.push(
          React.cloneElement(item, {
            head: 'true'
          })
        );
      } else {
        footerScript.push(item);
      }
    });
  }

  if (bundles.length) {
    bundles.forEach((bundle, index) => {
      if (/\.js$/.test(bundle.publicPath)) {
        if (!/hot-update\.js/.test(bundle.publicPath)) {
          bundleScript.push(
            React.createElement('script', {
              src: bundle.publicPath,
              key: index
            })
          );
        }
      } else if (/\.css$/.test(bundle.publicPath)) {
        bundleStyle.push(
          React.createElement('link', {
            key: index,
            rel: 'stylesheet',
            type: 'text/css',
            href: bundle.publicPath
          })
        );
      }
    });
  }

  return {
    head: React.createElement(
      React.Fragment,
      null,
      title,
      meta,
      link,
      createStyleLink(ctx),
      bundleStyle,
      headScript
    ),
    script: footerScript,
    bundleScript,
    html
  };
};
