'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

const _1 = require('./');

const utils_1 = require('../utils');

class Plugin {
  constructor(hooks, options = {}, name) {
    /**
     * 插件动态变量对象
     */
    this.options = {};
    this.__plugin__self__hooks__ = hooks;
    this.__plugin__name__ = name;
    this.options = options;
  }

  method(callback, methodName) {
    const self = this;
    const obj = {};

    _1.default.names[methodName].forEach(name => {
      const { name: fnName } = utils_1.parseAsync(name);

      obj[fnName] = function() {
        self.__plugin__self__hooks__[fnName](...arguments);
      };
    });

    try {
      callback(obj);
    } catch (error) {
      console.error(`[ plugin-name: ${this.__plugin__name__} ] Node端注册插件时发生错误\n${error}`);
    }
  }
  /**
   * 执行服务端运行阶段的钩子函数
   *
   * 主要对上下文参数的处理、中间件的处理以及数据加载和渲染逻辑的自定义调整
   *
   * `modifyContextMext`
   *
   * `modifyInitialPropsCtx`
   *
   * `willCache`
   *
   * `willFetch`
   *
   * `didFetch`
   *
   * `beforeCoreMiddlewares`
   *
   * `afterCoreMiddlewares`
   */

  server(callback) {
    this.method(callback, 'server');
  }
  /**
   * 渲染阶段触发钩子
   *
   * `beforeRender`
   *
   * `render`
   *
   * `document`
   *
   * `afterRender`
   */

  render(callback) {
    this.method(callback, 'render');
  }
  /**
   * build阶段执行钩子
   *
   * `beforeBuild`
   *
   * `source`
   *
   * `afterBuild`
   */

  build(callback) {
    this.method(callback, 'build');
  }
  /**
   * 自定义处理配置文件
   *
   * `webpackConfig`
   *
   * `babelConfig`
   */

  config(callback) {
    this.method(callback, 'config');
  }
  /**
   * 处理编译解决的场景，目前有webpack编译阶段的处理
   *
   * `webpackCompiler`
   */

  compiler(callback) {
    this.method(callback, 'compiler');
  }
}

exports.default = Plugin;
