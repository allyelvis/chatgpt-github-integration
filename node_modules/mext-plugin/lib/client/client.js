'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
/**
 * 客户端插件处理，包括插件注册、插件钩子存储、插件执行
 */

const utils_1 = require('../utils');

const storeApis = {};
const defaultApis = {};
const hooks = {};
let currentName = null;
let _mext_plugins_ = {}; // 客户端，babel识别到<$>__MEXT__PLUGINS__<$>，那么将对其注入下面插件代码

('<$>__MEXT__PLUGINS__<$>');

const asyncStart = async (hookName, params) => {
  const nameL = storeApis[hookName].length;
  let content = null;
  let result = true;

  if (nameL) {
    let i = 0;

    while (i < nameL) {
      const { fn, name } = storeApis[hookName][i];

      try {
        content = await fn.call(
          {
            content
          },
          params
        );

        if (typeof content === 'boolean' && !content) {
          // 一旦其中某个插件执行结果是false，那么针对布尔类型的返回值都将是false
          result = false;
        }

        i++;
      } catch (error) {
        throw new Error(
          `\n[ plugin-name:      ${name} ]\n[ plugin-hookName:  ${hookName} ]\n${error}`
        );
      }
    }
  }

  if (!result) {
    return false;
  }

  return content;
};

const syncStart = (hookName, params) => {
  const nameL = storeApis[hookName].length;
  let content = null;
  let result = true;

  if (nameL) {
    let i = 0;

    while (i < nameL) {
      const { fn, name } = storeApis[hookName][i];

      try {
        content = fn.call(
          {
            content
          },
          params
        );

        if (typeof content === 'boolean' && !content) {
          // 一旦其中某个插件执行结果是false，那么针对布尔类型的返回值都将是false
          result = false;
        }

        i++;
      } catch (error) {
        throw new Error(
          `\n[ plugin-name:      ${name} ]\n[ plugin-hookName:  ${hookName} ]\n${error}`
        );
      }
    }
  }

  if (!result) {
    return false;
  }

  return content;
};

exports.register = plugins => {
  plugins.forEach(item => {
    let name = null;
    let options = {};

    if (Array.isArray(item)) {
      name = item[0];
      options = item[1] || {};
    } else {
      name = item;
    }

    if (/^(.*)mext-plugin-(.*)/.test(name) && _mext_plugins_[name]) {
      // 客户端环境需要依赖babel的代码注入
      const client = _mext_plugins_[name].client;
      const run = client.default || client;
      currentName = name;

      try {
        if (run.prototype && run.prototype.apply) {
          new run(defaultApis, options, name).apply();
        } else {
          run(defaultApis, options);
        }
      } catch (error) {
        // 插件注册出错
        console.error(`[ plugin-name: ${name} ] 客户端注册插件时发生错误\n${error}`);
      }
    }
  });
};

exports.default = names => {
  names.forEach(name => {
    const { name: fnName, type: fnType } = utils_1.parseAsync(name);
    storeApis[fnName] = [];

    defaultApis[fnName] = cb => {
      storeApis[fnName].push({
        fn: cb,
        name: currentName
      });
    };

    if (fnType === 'sync') {
      // 同步任务
      hooks[fnName] = params => {
        return syncStart(fnName, params);
      };
    }

    if (fnType === 'async') {
      // 异步任务
      hooks[fnName] = async params => {
        return await asyncStart(fnName, params);
      };
    }
  });
  return hooks;
};
